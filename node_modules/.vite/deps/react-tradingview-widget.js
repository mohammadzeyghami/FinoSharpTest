import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/react-tradingview-widget/dist/manifest.js
var require_manifest = __commonJS({
  "node_modules/react-tradingview-widget/dist/manifest.js"() {
    (function(modules) {
      var parentJsonpFunction = window["webpackJsonpreact_tradingview_widget"];
      window["webpackJsonpreact_tradingview_widget"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
        var moduleId, chunkId, i = 0, resolves = [], result;
        for (; i < chunkIds.length; i++) {
          chunkId = chunkIds[i];
          if (installedChunks[chunkId]) {
            resolves.push(installedChunks[chunkId][0]);
          }
          installedChunks[chunkId] = 0;
        }
        for (moduleId in moreModules) {
          if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
            modules[moduleId] = moreModules[moduleId];
          }
        }
        if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
        while (resolves.length) {
          resolves.shift()();
        }
        if (executeModules) {
          for (i = 0; i < executeModules.length; i++) {
            result = __webpack_require__(__webpack_require__.s = executeModules[i]);
          }
        }
        return result;
      };
      var installedModules = {};
      var installedChunks = {
        /******/
        2: 0
        /******/
      };
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
          /******/
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, {
            /******/
            configurable: false,
            /******/
            enumerable: true,
            /******/
            get: getter
            /******/
          });
        }
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? (
          /******/
          function getDefault() {
            return module2["default"];
          }
        ) : (
          /******/
          function getModuleExports() {
            return module2;
          }
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      __webpack_require__.oe = function(err) {
        console.error(err);
        throw err;
      };
    })([]);
  }
});

// node_modules/react-tradingview-widget/dist/vendor.js
var require_vendor = __commonJS({
  "node_modules/react-tradingview-widget/dist/vendor.js"() {
    webpackJsonpreact_tradingview_widget([0], [
      /* 0 */
      /***/
      function(module2, exports2) {
        var process = module2.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      },
      /* 1 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        function makeEmptyFunction(arg) {
          return function() {
            return arg;
          };
        }
        var emptyFunction = function emptyFunction2() {
        };
        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function() {
          return this;
        };
        emptyFunction.thatReturnsArgument = function(arg) {
          return arg;
        };
        module2.exports = emptyFunction;
      },
      /* 2 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          var validateFormat = function validateFormat2(format) {
          };
          if (process.env.NODE_ENV !== "production") {
            validateFormat = function validateFormat2(format) {
              if (format === void 0) {
                throw new Error("invariant requires an error message argument");
              }
            };
          }
          function invariant(condition, format, a, b, c, d, e, f) {
            validateFormat(format);
            if (!condition) {
              var error;
              if (format === void 0) {
                error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
              } else {
                var args = [a, b, c, d, e, f];
                var argIndex = 0;
                error = new Error(format.replace(/%s/g, function() {
                  return args[argIndex++];
                }));
                error.name = "Invariant Violation";
              }
              error.framesToPop = 1;
              throw error;
            }
          }
          module2.exports = invariant;
        }).call(exports2, __webpack_require__(0));
      },
      /* 3 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Object.assign cannot be called with null or undefined");
          }
          return Object(val);
        }
        function shouldUseNative() {
          try {
            if (!Object.assign) {
              return false;
            }
            var test1 = new String("abc");
            test1[5] = "de";
            if (Object.getOwnPropertyNames(test1)[0] === "5") {
              return false;
            }
            var test2 = {};
            for (var i = 0; i < 10; i++) {
              test2["_" + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
              return test2[n];
            });
            if (order2.join("") !== "0123456789") {
              return false;
            }
            var test3 = {};
            "abcdefghijklmnopqrst".split("").forEach(function(letter) {
              test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
          var from;
          var to = toObject(target);
          var symbols;
          for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }
            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  to[symbols[i]] = from[symbols[i]];
                }
              }
            }
          }
          return to;
        };
      },
      /* 4 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          var emptyFunction = __webpack_require__(1);
          var warning = emptyFunction;
          if (process.env.NODE_ENV !== "production") {
            var printWarning = function printWarning2(format) {
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args[argIndex++];
              });
              if (typeof console !== "undefined") {
                console.error(message);
              }
              try {
                throw new Error(message);
              } catch (x) {
              }
            };
            warning = function warning2(condition, format) {
              if (format === void 0) {
                throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
              }
              if (format.indexOf("Failed Composite propType: ") === 0) {
                return;
              }
              if (!condition) {
                for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                  args[_key2 - 2] = arguments[_key2];
                }
                printWarning.apply(void 0, [format].concat(args));
              }
            };
          }
          module2.exports = warning;
        }).call(exports2, __webpack_require__(0));
      },
      /* 5 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        module2.exports = ReactPropTypesSecret;
      },
      /* 6 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          var emptyObject = {};
          if (process.env.NODE_ENV !== "production") {
            Object.freeze(emptyObject);
          }
          module2.exports = emptyObject;
        }).call(exports2, __webpack_require__(0));
      },
      /* 7 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          if (process.env.NODE_ENV !== "production") {
            var invariant = __webpack_require__(2);
            var warning = __webpack_require__(4);
            var ReactPropTypesSecret = __webpack_require__(5);
            var loggedTypeFailures = {};
          }
          function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
            if (process.env.NODE_ENV !== "production") {
              for (var typeSpecName in typeSpecs) {
                if (typeSpecs.hasOwnProperty(typeSpecName)) {
                  var error;
                  try {
                    invariant(typeof typeSpecs[typeSpecName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from the `prop-types` package, but received `%s`.", componentName || "React class", location, typeSpecName, typeof typeSpecs[typeSpecName]);
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                  } catch (ex) {
                    error = ex;
                  }
                  warning(!error || error instanceof Error, "%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error);
                  if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : "";
                    warning(false, "Failed %s type: %s%s", location, error.message, stack != null ? stack : "");
                  }
                }
              }
            }
          }
          module2.exports = checkPropTypes;
        }).call(exports2, __webpack_require__(0));
      },
      ,
      /* 9 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          if (process.env.NODE_ENV === "production") {
            module2.exports = __webpack_require__(10);
          } else {
            module2.exports = __webpack_require__(11);
          }
        }).call(exports2, __webpack_require__(0));
      },
      /* 10 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        var m = __webpack_require__(3), n = __webpack_require__(6), p = __webpack_require__(1), q = "function" === typeof Symbol && Symbol["for"], r = q ? Symbol["for"]("react.element") : 60103, t = q ? Symbol["for"]("react.call") : 60104, u = q ? Symbol["for"]("react.return") : 60105, v = q ? Symbol["for"]("react.portal") : 60106, w = q ? Symbol["for"]("react.fragment") : 60107, x = "function" === typeof Symbol && Symbol.iterator;
        function y(a) {
          for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant=" + a, c = 0; c < b; c++) e += "&args[]=" + encodeURIComponent(arguments[c + 1]);
          b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
          b.name = "Invariant Violation";
          b.framesToPop = 1;
          throw b;
        }
        var z = { isMounted: function() {
          return false;
        }, enqueueForceUpdate: function() {
        }, enqueueReplaceState: function() {
        }, enqueueSetState: function() {
        } };
        function A(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = n;
          this.updater = e || z;
        }
        A.prototype.isReactComponent = {};
        A.prototype.setState = function(a, b) {
          "object" !== typeof a && "function" !== typeof a && null != a ? y("85") : void 0;
          this.updater.enqueueSetState(this, a, b, "setState");
        };
        A.prototype.forceUpdate = function(a) {
          this.updater.enqueueForceUpdate(this, a, "forceUpdate");
        };
        function B(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = n;
          this.updater = e || z;
        }
        function C() {
        }
        C.prototype = A.prototype;
        var D = B.prototype = new C();
        D.constructor = B;
        m(D, A.prototype);
        D.isPureReactComponent = true;
        function E(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = n;
          this.updater = e || z;
        }
        var F = E.prototype = new C();
        F.constructor = E;
        m(F, A.prototype);
        F.unstable_isAsyncReactComponent = true;
        F.render = function() {
          return this.props.children;
        };
        var G = { current: null }, H = Object.prototype.hasOwnProperty, I = { key: true, ref: true, __self: true, __source: true };
        function J(a, b, e) {
          var c, d = {}, g = null, k = null;
          if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
          var f = arguments.length - 2;
          if (1 === f) d.children = e;
          else if (1 < f) {
            for (var h = Array(f), l = 0; l < f; l++) h[l] = arguments[l + 2];
            d.children = h;
          }
          if (a && a.defaultProps) for (c in f = a.defaultProps, f) void 0 === d[c] && (d[c] = f[c]);
          return { $$typeof: r, type: a, key: g, ref: k, props: d, _owner: G.current };
        }
        function K(a) {
          return "object" === typeof a && null !== a && a.$$typeof === r;
        }
        function escape(a) {
          var b = { "=": "=0", ":": "=2" };
          return "$" + ("" + a).replace(/[=:]/g, function(a2) {
            return b[a2];
          });
        }
        var L = /\/+/g, M = [];
        function N(a, b, e, c) {
          if (M.length) {
            var d = M.pop();
            d.result = a;
            d.keyPrefix = b;
            d.func = e;
            d.context = c;
            d.count = 0;
            return d;
          }
          return { result: a, keyPrefix: b, func: e, context: c, count: 0 };
        }
        function O(a) {
          a.result = null;
          a.keyPrefix = null;
          a.func = null;
          a.context = null;
          a.count = 0;
          10 > M.length && M.push(a);
        }
        function P(a, b, e, c) {
          var d = typeof a;
          if ("undefined" === d || "boolean" === d) a = null;
          var g = false;
          if (null === a) g = true;
          else switch (d) {
            case "string":
            case "number":
              g = true;
              break;
            case "object":
              switch (a.$$typeof) {
                case r:
                case t:
                case u:
                case v:
                  g = true;
              }
          }
          if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;
          g = 0;
          b = "" === b ? "." : b + ":";
          if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
            d = a[k];
            var f = b + Q(d, k);
            g += P(d, f, e, c);
          }
          else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done; ) d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);
          else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
          return g;
        }
        function Q(a, b) {
          return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
        }
        function R(a, b) {
          a.func.call(a.context, b, a.count++);
        }
        function S(a, b, e) {
          var c = a.result, d = a.keyPrefix;
          a = a.func.call(a.context, b, a.count++);
          Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$&/") + "/") + e, a = { $$typeof: r, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), c.push(a));
        }
        function T(a, b, e, c, d) {
          var g = "";
          null != e && (g = ("" + e).replace(L, "$&/") + "/");
          b = N(b, g, c, d);
          null == a || P(a, "", S, b);
          O(b);
        }
        var U = {
          Children: { map: function(a, b, e) {
            if (null == a) return a;
            var c = [];
            T(a, c, null, b, e);
            return c;
          }, forEach: function(a, b, e) {
            if (null == a) return a;
            b = N(null, null, b, e);
            null == a || P(a, "", R, b);
            O(b);
          }, count: function(a) {
            return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
          }, toArray: function(a) {
            var b = [];
            T(a, b, null, p.thatReturnsArgument);
            return b;
          }, only: function(a) {
            K(a) ? void 0 : y("143");
            return a;
          } },
          Component: A,
          PureComponent: B,
          unstable_AsyncComponent: E,
          Fragment: w,
          createElement: J,
          cloneElement: function(a, b, e) {
            var c = m({}, a.props), d = a.key, g = a.ref, k = a._owner;
            if (null != b) {
              void 0 !== b.ref && (g = b.ref, k = G.current);
              void 0 !== b.key && (d = "" + b.key);
              if (a.type && a.type.defaultProps) var f = a.type.defaultProps;
              for (h in b) H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
            }
            var h = arguments.length - 2;
            if (1 === h) c.children = e;
            else if (1 < h) {
              f = Array(h);
              for (var l = 0; l < h; l++) f[l] = arguments[l + 2];
              c.children = f;
            }
            return { $$typeof: r, type: a.type, key: d, ref: g, props: c, _owner: k };
          },
          createFactory: function(a) {
            var b = J.bind(null, a);
            b.type = a;
            return b;
          },
          isValidElement: K,
          version: "16.2.0",
          __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: G, assign: m }
        }, V = Object.freeze({ default: U }), W = V && U || V;
        module2.exports = W["default"] ? W["default"] : W;
      },
      /* 11 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          if (process.env.NODE_ENV !== "production") {
            (function() {
              "use strict";
              var _assign = __webpack_require__(3);
              var emptyObject = __webpack_require__(6);
              var invariant = __webpack_require__(2);
              var warning = __webpack_require__(4);
              var emptyFunction = __webpack_require__(1);
              var checkPropTypes = __webpack_require__(7);
              var ReactVersion = "16.2.0";
              var hasSymbol = typeof Symbol === "function" && Symbol["for"];
              var REACT_ELEMENT_TYPE = hasSymbol ? Symbol["for"]("react.element") : 60103;
              var REACT_CALL_TYPE = hasSymbol ? Symbol["for"]("react.call") : 60104;
              var REACT_RETURN_TYPE = hasSymbol ? Symbol["for"]("react.return") : 60105;
              var REACT_PORTAL_TYPE = hasSymbol ? Symbol["for"]("react.portal") : 60106;
              var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol["for"]("react.fragment") : 60107;
              var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
              var FAUX_ITERATOR_SYMBOL = "@@iterator";
              function getIteratorFn(maybeIterable) {
                if (maybeIterable === null || typeof maybeIterable === "undefined") {
                  return null;
                }
                var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
                if (typeof maybeIterator === "function") {
                  return maybeIterator;
                }
                return null;
              }
              var lowPriorityWarning = function() {
              };
              {
                var printWarning = function(format) {
                  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  var argIndex = 0;
                  var message = "Warning: " + format.replace(/%s/g, function() {
                    return args[argIndex++];
                  });
                  if (typeof console !== "undefined") {
                    console.warn(message);
                  }
                  try {
                    throw new Error(message);
                  } catch (x) {
                  }
                };
                lowPriorityWarning = function(condition, format) {
                  if (format === void 0) {
                    throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                  }
                  if (!condition) {
                    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                      args[_key2 - 2] = arguments[_key2];
                    }
                    printWarning.apply(void 0, [format].concat(args));
                  }
                };
              }
              var lowPriorityWarning$1 = lowPriorityWarning;
              var didWarnStateUpdateForUnmountedComponent = {};
              function warnNoop(publicInstance, callerName) {
                {
                  var constructor = publicInstance.constructor;
                  var componentName = constructor && (constructor.displayName || constructor.name) || "ReactClass";
                  var warningKey = componentName + "." + callerName;
                  if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                  }
                  warning(false, "%s(...): Can only update a mounted or mounting component. This usually means you called %s() on an unmounted component. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
                  didWarnStateUpdateForUnmountedComponent[warningKey] = true;
                }
              }
              var ReactNoopUpdateQueue = {
                /**
                 * Checks whether or not this composite component is mounted.
                 * @param {ReactClass} publicInstance The instance we want to test.
                 * @return {boolean} True if mounted, false otherwise.
                 * @protected
                 * @final
                 */
                isMounted: function(publicInstance) {
                  return false;
                },
                /**
                 * Forces an update. This should only be invoked when it is known with
                 * certainty that we are **not** in a DOM transaction.
                 *
                 * You may want to call this when you know that some deeper aspect of the
                 * component's state has changed but `setState` was not called.
                 *
                 * This will not invoke `shouldComponentUpdate`, but it will invoke
                 * `componentWillUpdate` and `componentDidUpdate`.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {?function} callback Called after component is updated.
                 * @param {?string} callerName name of the calling function in the public API.
                 * @internal
                 */
                enqueueForceUpdate: function(publicInstance, callback, callerName) {
                  warnNoop(publicInstance, "forceUpdate");
                },
                /**
                 * Replaces all of the state. Always use this or `setState` to mutate state.
                 * You should treat `this.state` as immutable.
                 *
                 * There is no guarantee that `this.state` will be immediately updated, so
                 * accessing `this.state` after calling this method may return the old value.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} completeState Next state.
                 * @param {?function} callback Called after component is updated.
                 * @param {?string} callerName name of the calling function in the public API.
                 * @internal
                 */
                enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                  warnNoop(publicInstance, "replaceState");
                },
                /**
                 * Sets a subset of the state. This only exists because _pendingState is
                 * internal. This provides a merging strategy that is not available to deep
                 * properties which is confusing. TODO: Expose pendingState or don't use it
                 * during the merge.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} partialState Next partial state to be merged with state.
                 * @param {?function} callback Called after component is updated.
                 * @param {?string} Name of the calling function in the public API.
                 * @internal
                 */
                enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                  warnNoop(publicInstance, "setState");
                }
              };
              function Component(props, context, updater) {
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                this.updater = updater || ReactNoopUpdateQueue;
              }
              Component.prototype.isReactComponent = {};
              Component.prototype.setState = function(partialState, callback) {
                !(typeof partialState === "object" || typeof partialState === "function" || partialState == null) ? invariant(false, "setState(...): takes an object of state variables to update or a function which returns an object of state variables.") : void 0;
                this.updater.enqueueSetState(this, partialState, callback, "setState");
              };
              Component.prototype.forceUpdate = function(callback) {
                this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
              };
              {
                var deprecatedAPIs = {
                  isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
                  replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
                };
                var defineDeprecationWarning = function(methodName, info) {
                  Object.defineProperty(Component.prototype, methodName, {
                    get: function() {
                      lowPriorityWarning$1(false, "%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                      return void 0;
                    }
                  });
                };
                for (var fnName in deprecatedAPIs) {
                  if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                  }
                }
              }
              function PureComponent(props, context, updater) {
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                this.updater = updater || ReactNoopUpdateQueue;
              }
              function ComponentDummy() {
              }
              ComponentDummy.prototype = Component.prototype;
              var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
              pureComponentPrototype.constructor = PureComponent;
              _assign(pureComponentPrototype, Component.prototype);
              pureComponentPrototype.isPureReactComponent = true;
              function AsyncComponent(props, context, updater) {
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                this.updater = updater || ReactNoopUpdateQueue;
              }
              var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
              asyncComponentPrototype.constructor = AsyncComponent;
              _assign(asyncComponentPrototype, Component.prototype);
              asyncComponentPrototype.unstable_isAsyncReactComponent = true;
              asyncComponentPrototype.render = function() {
                return this.props.children;
              };
              var ReactCurrentOwner = {
                /**
                 * @internal
                 * @type {ReactComponent}
                 */
                current: null
              };
              var hasOwnProperty = Object.prototype.hasOwnProperty;
              var RESERVED_PROPS = {
                key: true,
                ref: true,
                __self: true,
                __source: true
              };
              var specialPropKeyWarningShown;
              var specialPropRefWarningShown;
              function hasValidRef(config) {
                {
                  if (hasOwnProperty.call(config, "ref")) {
                    var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                    if (getter && getter.isReactWarning) {
                      return false;
                    }
                  }
                }
                return config.ref !== void 0;
              }
              function hasValidKey(config) {
                {
                  if (hasOwnProperty.call(config, "key")) {
                    var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                    if (getter && getter.isReactWarning) {
                      return false;
                    }
                  }
                }
                return config.key !== void 0;
              }
              function defineKeyPropWarningGetter(props, displayName) {
                var warnAboutAccessingKey = function() {
                  if (!specialPropKeyWarningShown) {
                    specialPropKeyWarningShown = true;
                    warning(false, "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
                  }
                };
                warnAboutAccessingKey.isReactWarning = true;
                Object.defineProperty(props, "key", {
                  get: warnAboutAccessingKey,
                  configurable: true
                });
              }
              function defineRefPropWarningGetter(props, displayName) {
                var warnAboutAccessingRef = function() {
                  if (!specialPropRefWarningShown) {
                    specialPropRefWarningShown = true;
                    warning(false, "%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
                  }
                };
                warnAboutAccessingRef.isReactWarning = true;
                Object.defineProperty(props, "ref", {
                  get: warnAboutAccessingRef,
                  configurable: true
                });
              }
              var ReactElement = function(type, key, ref, self2, source, owner, props) {
                var element = {
                  // This tag allow us to uniquely identify this as a React Element
                  $$typeof: REACT_ELEMENT_TYPE,
                  // Built-in properties that belong on the element
                  type,
                  key,
                  ref,
                  props,
                  // Record the component responsible for creating this element.
                  _owner: owner
                };
                {
                  element._store = {};
                  Object.defineProperty(element._store, "validated", {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                  });
                  Object.defineProperty(element, "_self", {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self2
                  });
                  Object.defineProperty(element, "_source", {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                  });
                  if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                  }
                }
                return element;
              };
              function createElement(type, config, children) {
                var propName;
                var props = {};
                var key = null;
                var ref = null;
                var self2 = null;
                var source = null;
                if (config != null) {
                  if (hasValidRef(config)) {
                    ref = config.ref;
                  }
                  if (hasValidKey(config)) {
                    key = "" + config.key;
                  }
                  self2 = config.__self === void 0 ? null : config.__self;
                  source = config.__source === void 0 ? null : config.__source;
                  for (propName in config) {
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                      props[propName] = config[propName];
                    }
                  }
                }
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                  props.children = children;
                } else if (childrenLength > 1) {
                  var childArray = Array(childrenLength);
                  for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 2];
                  }
                  {
                    if (Object.freeze) {
                      Object.freeze(childArray);
                    }
                  }
                  props.children = childArray;
                }
                if (type && type.defaultProps) {
                  var defaultProps = type.defaultProps;
                  for (propName in defaultProps) {
                    if (props[propName] === void 0) {
                      props[propName] = defaultProps[propName];
                    }
                  }
                }
                {
                  if (key || ref) {
                    if (typeof props.$$typeof === "undefined" || props.$$typeof !== REACT_ELEMENT_TYPE) {
                      var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                      if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                      }
                      if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                      }
                    }
                  }
                }
                return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
              }
              function cloneAndReplaceKey(oldElement, newKey) {
                var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
                return newElement;
              }
              function cloneElement(element, config, children) {
                var propName;
                var props = _assign({}, element.props);
                var key = element.key;
                var ref = element.ref;
                var self2 = element._self;
                var source = element._source;
                var owner = element._owner;
                if (config != null) {
                  if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                  }
                  if (hasValidKey(config)) {
                    key = "" + config.key;
                  }
                  var defaultProps;
                  if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                  }
                  for (propName in config) {
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                      if (config[propName] === void 0 && defaultProps !== void 0) {
                        props[propName] = defaultProps[propName];
                      } else {
                        props[propName] = config[propName];
                      }
                    }
                  }
                }
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                  props.children = children;
                } else if (childrenLength > 1) {
                  var childArray = Array(childrenLength);
                  for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 2];
                  }
                  props.children = childArray;
                }
                return ReactElement(element.type, key, ref, self2, source, owner, props);
              }
              function isValidElement(object) {
                return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
              }
              var ReactDebugCurrentFrame = {};
              {
                ReactDebugCurrentFrame.getCurrentStack = null;
                ReactDebugCurrentFrame.getStackAddendum = function() {
                  var impl = ReactDebugCurrentFrame.getCurrentStack;
                  if (impl) {
                    return impl();
                  }
                  return null;
                };
              }
              var SEPARATOR = ".";
              var SUBSEPARATOR = ":";
              function escape(key) {
                var escapeRegex = /[=:]/g;
                var escaperLookup = {
                  "=": "=0",
                  ":": "=2"
                };
                var escapedString = ("" + key).replace(escapeRegex, function(match) {
                  return escaperLookup[match];
                });
                return "$" + escapedString;
              }
              var didWarnAboutMaps = false;
              var userProvidedKeyEscapeRegex = /\/+/g;
              function escapeUserProvidedKey(text) {
                return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
              }
              var POOL_SIZE = 10;
              var traverseContextPool = [];
              function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
                if (traverseContextPool.length) {
                  var traverseContext = traverseContextPool.pop();
                  traverseContext.result = mapResult;
                  traverseContext.keyPrefix = keyPrefix;
                  traverseContext.func = mapFunction;
                  traverseContext.context = mapContext;
                  traverseContext.count = 0;
                  return traverseContext;
                } else {
                  return {
                    result: mapResult,
                    keyPrefix,
                    func: mapFunction,
                    context: mapContext,
                    count: 0
                  };
                }
              }
              function releaseTraverseContext(traverseContext) {
                traverseContext.result = null;
                traverseContext.keyPrefix = null;
                traverseContext.func = null;
                traverseContext.context = null;
                traverseContext.count = 0;
                if (traverseContextPool.length < POOL_SIZE) {
                  traverseContextPool.push(traverseContext);
                }
              }
              function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                var type = typeof children;
                if (type === "undefined" || type === "boolean") {
                  children = null;
                }
                var invokeCallback = false;
                if (children === null) {
                  invokeCallback = true;
                } else {
                  switch (type) {
                    case "string":
                    case "number":
                      invokeCallback = true;
                      break;
                    case "object":
                      switch (children.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                        case REACT_CALL_TYPE:
                        case REACT_RETURN_TYPE:
                        case REACT_PORTAL_TYPE:
                          invokeCallback = true;
                      }
                  }
                }
                if (invokeCallback) {
                  callback(
                    traverseContext,
                    children,
                    // If it's the only child, treat the name as if it was wrapped in an array
                    // so that it's consistent if the number of children grows.
                    nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
                  );
                  return 1;
                }
                var child;
                var nextName;
                var subtreeCount = 0;
                var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    nextName = nextNamePrefix + getComponentKey(child, i);
                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    {
                      if (iteratorFn === children.entries) {
                        warning(didWarnAboutMaps, "Using Maps as children is unsupported and will likely yield unexpected results. Convert it to a sequence/iterable of keyed ReactElements instead.%s", ReactDebugCurrentFrame.getStackAddendum());
                        didWarnAboutMaps = true;
                      }
                    }
                    var iterator = iteratorFn.call(children);
                    var step;
                    var ii = 0;
                    while (!(step = iterator.next()).done) {
                      child = step.value;
                      nextName = nextNamePrefix + getComponentKey(child, ii++);
                      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                    }
                  } else if (type === "object") {
                    var addendum = "";
                    {
                      addendum = " If you meant to render a collection of children, use an array instead." + ReactDebugCurrentFrame.getStackAddendum();
                    }
                    var childrenString = "" + children;
                    invariant(false, "Objects are not valid as a React child (found: %s).%s", childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString, addendum);
                  }
                }
                return subtreeCount;
              }
              function traverseAllChildren(children, callback, traverseContext) {
                if (children == null) {
                  return 0;
                }
                return traverseAllChildrenImpl(children, "", callback, traverseContext);
              }
              function getComponentKey(component, index) {
                if (typeof component === "object" && component !== null && component.key != null) {
                  return escape(component.key);
                }
                return index.toString(36);
              }
              function forEachSingleChild(bookKeeping, child, name) {
                var func = bookKeeping.func, context = bookKeeping.context;
                func.call(context, child, bookKeeping.count++);
              }
              function forEachChildren(children, forEachFunc, forEachContext) {
                if (children == null) {
                  return children;
                }
                var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
                traverseAllChildren(children, forEachSingleChild, traverseContext);
                releaseTraverseContext(traverseContext);
              }
              function mapSingleChildIntoContext(bookKeeping, child, childKey) {
                var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
                var mappedChild = func.call(context, child, bookKeeping.count++);
                if (Array.isArray(mappedChild)) {
                  mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
                } else if (mappedChild != null) {
                  if (isValidElement(mappedChild)) {
                    mappedChild = cloneAndReplaceKey(
                      mappedChild,
                      // Keep both the (mapped) and old keys if they differ, just as
                      // traverseAllChildren used to do for objects as children
                      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey
                    );
                  }
                  result.push(mappedChild);
                }
              }
              function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
                var escapedPrefix = "";
                if (prefix != null) {
                  escapedPrefix = escapeUserProvidedKey(prefix) + "/";
                }
                var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
                traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
                releaseTraverseContext(traverseContext);
              }
              function mapChildren(children, func, context) {
                if (children == null) {
                  return children;
                }
                var result = [];
                mapIntoWithKeyPrefixInternal(children, result, null, func, context);
                return result;
              }
              function countChildren(children, context) {
                return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
              }
              function toArray(children) {
                var result = [];
                mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
                return result;
              }
              function onlyChild(children) {
                !isValidElement(children) ? invariant(false, "React.Children.only expected to receive a single React element child.") : void 0;
                return children;
              }
              var describeComponentFrame = function(name, source, ownerName) {
                return "\n    in " + (name || "Unknown") + (source ? " (at " + source.fileName.replace(/^.*[\\\/]/, "") + ":" + source.lineNumber + ")" : ownerName ? " (created by " + ownerName + ")" : "");
              };
              function getComponentName(fiber) {
                var type = fiber.type;
                if (typeof type === "string") {
                  return type;
                }
                if (typeof type === "function") {
                  return type.displayName || type.name;
                }
                return null;
              }
              {
                var currentlyValidatingElement = null;
                var propTypesMisspellWarningShown = false;
                var getDisplayName = function(element) {
                  if (element == null) {
                    return "#empty";
                  } else if (typeof element === "string" || typeof element === "number") {
                    return "#text";
                  } else if (typeof element.type === "string") {
                    return element.type;
                  } else if (element.type === REACT_FRAGMENT_TYPE) {
                    return "React.Fragment";
                  } else {
                    return element.type.displayName || element.type.name || "Unknown";
                  }
                };
                var getStackAddendum = function() {
                  var stack = "";
                  if (currentlyValidatingElement) {
                    var name = getDisplayName(currentlyValidatingElement);
                    var owner = currentlyValidatingElement._owner;
                    stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
                  }
                  stack += ReactDebugCurrentFrame.getStackAddendum() || "";
                  return stack;
                };
                var VALID_FRAGMENT_PROPS = /* @__PURE__ */ new Map([["children", true], ["key", true]]);
              }
              function getDeclarationErrorAddendum() {
                if (ReactCurrentOwner.current) {
                  var name = getComponentName(ReactCurrentOwner.current);
                  if (name) {
                    return "\n\nCheck the render method of `" + name + "`.";
                  }
                }
                return "";
              }
              function getSourceInfoErrorAddendum(elementProps) {
                if (elementProps !== null && elementProps !== void 0 && elementProps.__source !== void 0) {
                  var source = elementProps.__source;
                  var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                  var lineNumber = source.lineNumber;
                  return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
                }
                return "";
              }
              var ownerHasKeyUseWarning = {};
              function getCurrentComponentErrorInfo(parentType) {
                var info = getDeclarationErrorAddendum();
                if (!info) {
                  var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                  if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                  }
                }
                return info;
              }
              function validateExplicitKey(element, parentType) {
                if (!element._store || element._store.validated || element.key != null) {
                  return;
                }
                element._store.validated = true;
                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                  return;
                }
                ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                var childOwner = "";
                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                  childOwner = " It was passed a child from " + getComponentName(element._owner) + ".";
                }
                currentlyValidatingElement = element;
                {
                  warning(false, 'Each child in an array or iterator should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
                }
                currentlyValidatingElement = null;
              }
              function validateChildKeys(node, parentType) {
                if (typeof node !== "object") {
                  return;
                }
                if (Array.isArray(node)) {
                  for (var i = 0; i < node.length; i++) {
                    var child = node[i];
                    if (isValidElement(child)) {
                      validateExplicitKey(child, parentType);
                    }
                  }
                } else if (isValidElement(node)) {
                  if (node._store) {
                    node._store.validated = true;
                  }
                } else if (node) {
                  var iteratorFn = getIteratorFn(node);
                  if (typeof iteratorFn === "function") {
                    if (iteratorFn !== node.entries) {
                      var iterator = iteratorFn.call(node);
                      var step;
                      while (!(step = iterator.next()).done) {
                        if (isValidElement(step.value)) {
                          validateExplicitKey(step.value, parentType);
                        }
                      }
                    }
                  }
                }
              }
              function validatePropTypes(element) {
                var componentClass = element.type;
                if (typeof componentClass !== "function") {
                  return;
                }
                var name = componentClass.displayName || componentClass.name;
                var propTypes = componentClass.propTypes;
                if (propTypes) {
                  currentlyValidatingElement = element;
                  checkPropTypes(propTypes, element.props, "prop", name, getStackAddendum);
                  currentlyValidatingElement = null;
                } else if (componentClass.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                  propTypesMisspellWarningShown = true;
                  warning(false, "Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
                }
                if (typeof componentClass.getDefaultProps === "function") {
                  warning(componentClass.getDefaultProps.isReactClassApproved, "getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
                }
              }
              function validateFragmentProps(fragment) {
                currentlyValidatingElement = fragment;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = void 0;
                try {
                  for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var key = _step.value;
                    if (!VALID_FRAGMENT_PROPS.has(key)) {
                      warning(false, "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.%s", key, getStackAddendum());
                      break;
                    }
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
                if (fragment.ref !== null) {
                  warning(false, "Invalid attribute `ref` supplied to `React.Fragment`.%s", getStackAddendum());
                }
                currentlyValidatingElement = null;
              }
              function createElementWithValidation(type, props, children) {
                var validType = typeof type === "string" || typeof type === "function" || typeof type === "symbol" || typeof type === "number";
                if (!validType) {
                  var info = "";
                  if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                    info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                  }
                  var sourceInfo = getSourceInfoErrorAddendum(props);
                  if (sourceInfo) {
                    info += sourceInfo;
                  } else {
                    info += getDeclarationErrorAddendum();
                  }
                  info += getStackAddendum() || "";
                  warning(false, "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", type == null ? type : typeof type, info);
                }
                var element = createElement.apply(this, arguments);
                if (element == null) {
                  return element;
                }
                if (validType) {
                  for (var i = 2; i < arguments.length; i++) {
                    validateChildKeys(arguments[i], type);
                  }
                }
                if (typeof type === "symbol" && type === REACT_FRAGMENT_TYPE) {
                  validateFragmentProps(element);
                } else {
                  validatePropTypes(element);
                }
                return element;
              }
              function createFactoryWithValidation(type) {
                var validatedFactory = createElementWithValidation.bind(null, type);
                validatedFactory.type = type;
                {
                  Object.defineProperty(validatedFactory, "type", {
                    enumerable: false,
                    get: function() {
                      lowPriorityWarning$1(false, "Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                      Object.defineProperty(this, "type", {
                        value: type
                      });
                      return type;
                    }
                  });
                }
                return validatedFactory;
              }
              function cloneElementWithValidation(element, props, children) {
                var newElement = cloneElement.apply(this, arguments);
                for (var i = 2; i < arguments.length; i++) {
                  validateChildKeys(arguments[i], newElement.type);
                }
                validatePropTypes(newElement);
                return newElement;
              }
              var React = {
                Children: {
                  map: mapChildren,
                  forEach: forEachChildren,
                  count: countChildren,
                  toArray,
                  only: onlyChild
                },
                Component,
                PureComponent,
                unstable_AsyncComponent: AsyncComponent,
                Fragment: REACT_FRAGMENT_TYPE,
                createElement: createElementWithValidation,
                cloneElement: cloneElementWithValidation,
                createFactory: createFactoryWithValidation,
                isValidElement,
                version: ReactVersion,
                __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                  ReactCurrentOwner,
                  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
                  assign: _assign
                }
              };
              {
                _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
                  // These should not be included in production.
                  ReactDebugCurrentFrame,
                  // Shim for React DOM 16.0.0 which still destructured (but not used) this.
                  // TODO: remove in React 17.0.
                  ReactComponentTreeHook: {}
                });
              }
              var React$2 = Object.freeze({
                default: React
              });
              var React$3 = React$2 && React || React$2;
              var react = React$3["default"] ? React$3["default"] : React$3;
              module2.exports = react;
            })();
          }
        }).call(exports2, __webpack_require__(0));
      },
      /* 12 */
      /***/
      function(module2, exports2, __webpack_require__) {
        (function(process) {
          if (process.env.NODE_ENV !== "production") {
            var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
            var isValidElement = function(object) {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            };
            var throwOnDirectAccess = true;
            module2.exports = __webpack_require__(13)(isValidElement, throwOnDirectAccess);
          } else {
            module2.exports = __webpack_require__(14)();
          }
        }).call(exports2, __webpack_require__(0));
      },
      /* 13 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(process) {
          var emptyFunction = __webpack_require__(1);
          var invariant = __webpack_require__(2);
          var warning = __webpack_require__(4);
          var assign = __webpack_require__(3);
          var ReactPropTypesSecret = __webpack_require__(5);
          var checkPropTypes = __webpack_require__(7);
          module2.exports = function(isValidElement, throwOnDirectAccess) {
            var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = "@@iterator";
            function getIteratorFn(maybeIterable) {
              var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
              if (typeof iteratorFn === "function") {
                return iteratorFn;
              }
            }
            var ANONYMOUS = "<<anonymous>>";
            var ReactPropTypes = {
              array: createPrimitiveTypeChecker("array"),
              bool: createPrimitiveTypeChecker("boolean"),
              func: createPrimitiveTypeChecker("function"),
              number: createPrimitiveTypeChecker("number"),
              object: createPrimitiveTypeChecker("object"),
              string: createPrimitiveTypeChecker("string"),
              symbol: createPrimitiveTypeChecker("symbol"),
              any: createAnyTypeChecker(),
              arrayOf: createArrayOfTypeChecker,
              element: createElementTypeChecker(),
              instanceOf: createInstanceTypeChecker,
              node: createNodeChecker(),
              objectOf: createObjectOfTypeChecker,
              oneOf: createEnumTypeChecker,
              oneOfType: createUnionTypeChecker,
              shape: createShapeTypeChecker,
              exact: createStrictShapeTypeChecker
            };
            function is(x, y) {
              if (x === y) {
                return x !== 0 || 1 / x === 1 / y;
              } else {
                return x !== x && y !== y;
              }
            }
            function PropTypeError(message) {
              this.message = message;
              this.stack = "";
            }
            PropTypeError.prototype = Error.prototype;
            function createChainableTypeChecker(validate) {
              if (process.env.NODE_ENV !== "production") {
                var manualPropTypeCallCache = {};
                var manualPropTypeWarningCount = 0;
              }
              function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                componentName = componentName || ANONYMOUS;
                propFullName = propFullName || propName;
                if (secret !== ReactPropTypesSecret) {
                  if (throwOnDirectAccess) {
                    invariant(
                      false,
                      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                    );
                  } else if (process.env.NODE_ENV !== "production" && typeof console !== "undefined") {
                    var cacheKey = componentName + ":" + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                      warning(
                        false,
                        "You are manually calling a React.PropTypes validation function for the `%s` prop on `%s`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.",
                        propFullName,
                        componentName
                      );
                      manualPropTypeCallCache[cacheKey] = true;
                      manualPropTypeWarningCount++;
                    }
                  }
                }
                if (props[propName] == null) {
                  if (isRequired) {
                    if (props[propName] === null) {
                      return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                    }
                    return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                  }
                  return null;
                } else {
                  return validate(props, propName, componentName, location, propFullName);
                }
              }
              var chainedCheckType = checkType.bind(null, false);
              chainedCheckType.isRequired = checkType.bind(null, true);
              return chainedCheckType;
            }
            function createPrimitiveTypeChecker(expectedType) {
              function validate(props, propName, componentName, location, propFullName, secret) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== expectedType) {
                  var preciseType = getPreciseType(propValue);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createAnyTypeChecker() {
              return createChainableTypeChecker(emptyFunction.thatReturnsNull);
            }
            function createArrayOfTypeChecker(typeChecker) {
              function validate(props, propName, componentName, location, propFullName) {
                if (typeof typeChecker !== "function") {
                  return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
                }
                var propValue = props[propName];
                if (!Array.isArray(propValue)) {
                  var propType = getPropType(propValue);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                }
                for (var i = 0; i < propValue.length; i++) {
                  var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
                  if (error instanceof Error) {
                    return error;
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createElementTypeChecker() {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                if (!isValidElement(propValue)) {
                  var propType = getPropType(propValue);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createInstanceTypeChecker(expectedClass) {
              function validate(props, propName, componentName, location, propFullName) {
                if (!(props[propName] instanceof expectedClass)) {
                  var expectedClassName = expectedClass.name || ANONYMOUS;
                  var actualClassName = getClassName(props[propName]);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createEnumTypeChecker(expectedValues) {
              if (!Array.isArray(expectedValues)) {
                process.env.NODE_ENV !== "production" ? warning(false, "Invalid argument supplied to oneOf, expected an instance of array.") : void 0;
                return emptyFunction.thatReturnsNull;
              }
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                for (var i = 0; i < expectedValues.length; i++) {
                  if (is(propValue, expectedValues[i])) {
                    return null;
                  }
                }
                var valuesString = JSON.stringify(expectedValues);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
              }
              return createChainableTypeChecker(validate);
            }
            function createObjectOfTypeChecker(typeChecker) {
              function validate(props, propName, componentName, location, propFullName) {
                if (typeof typeChecker !== "function") {
                  return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
                }
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                }
                for (var key in propValue) {
                  if (propValue.hasOwnProperty(key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                    if (error instanceof Error) {
                      return error;
                    }
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createUnionTypeChecker(arrayOfTypeCheckers) {
              if (!Array.isArray(arrayOfTypeCheckers)) {
                process.env.NODE_ENV !== "production" ? warning(false, "Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
                return emptyFunction.thatReturnsNull;
              }
              for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];
                if (typeof checker !== "function") {
                  warning(
                    false,
                    "Invalid argument supplied to oneOfType. Expected an array of check functions, but received %s at index %s.",
                    getPostfixForTypeWarning(checker),
                    i
                  );
                  return emptyFunction.thatReturnsNull;
                }
              }
              function validate(props, propName, componentName, location, propFullName) {
                for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
                  var checker2 = arrayOfTypeCheckers[i2];
                  if (checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                    return null;
                  }
                }
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
              }
              return createChainableTypeChecker(validate);
            }
            function createNodeChecker() {
              function validate(props, propName, componentName, location, propFullName) {
                if (!isNode(props[propName])) {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createShapeTypeChecker(shapeTypes) {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                }
                for (var key in shapeTypes) {
                  var checker = shapeTypes[key];
                  if (!checker) {
                    continue;
                  }
                  var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                  if (error) {
                    return error;
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createStrictShapeTypeChecker(shapeTypes) {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                }
                var allKeys = assign({}, props[propName], shapeTypes);
                for (var key in allKeys) {
                  var checker = shapeTypes[key];
                  if (!checker) {
                    return new PropTypeError(
                      "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                    );
                  }
                  var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                  if (error) {
                    return error;
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function isNode(propValue) {
              switch (typeof propValue) {
                case "number":
                case "string":
                case "undefined":
                  return true;
                case "boolean":
                  return !propValue;
                case "object":
                  if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                  }
                  if (propValue === null || isValidElement(propValue)) {
                    return true;
                  }
                  var iteratorFn = getIteratorFn(propValue);
                  if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                      while (!(step = iterator.next()).done) {
                        if (!isNode(step.value)) {
                          return false;
                        }
                      }
                    } else {
                      while (!(step = iterator.next()).done) {
                        var entry = step.value;
                        if (entry) {
                          if (!isNode(entry[1])) {
                            return false;
                          }
                        }
                      }
                    }
                  } else {
                    return false;
                  }
                  return true;
                default:
                  return false;
              }
            }
            function isSymbol(propType, propValue) {
              if (propType === "symbol") {
                return true;
              }
              if (propValue["@@toStringTag"] === "Symbol") {
                return true;
              }
              if (typeof Symbol === "function" && propValue instanceof Symbol) {
                return true;
              }
              return false;
            }
            function getPropType(propValue) {
              var propType = typeof propValue;
              if (Array.isArray(propValue)) {
                return "array";
              }
              if (propValue instanceof RegExp) {
                return "object";
              }
              if (isSymbol(propType, propValue)) {
                return "symbol";
              }
              return propType;
            }
            function getPreciseType(propValue) {
              if (typeof propValue === "undefined" || propValue === null) {
                return "" + propValue;
              }
              var propType = getPropType(propValue);
              if (propType === "object") {
                if (propValue instanceof Date) {
                  return "date";
                } else if (propValue instanceof RegExp) {
                  return "regexp";
                }
              }
              return propType;
            }
            function getPostfixForTypeWarning(value) {
              var type = getPreciseType(value);
              switch (type) {
                case "array":
                case "object":
                  return "an " + type;
                case "boolean":
                case "date":
                case "regexp":
                  return "a " + type;
                default:
                  return type;
              }
            }
            function getClassName(propValue) {
              if (!propValue.constructor || !propValue.constructor.name) {
                return ANONYMOUS;
              }
              return propValue.constructor.name;
            }
            ReactPropTypes.checkPropTypes = checkPropTypes;
            ReactPropTypes.PropTypes = ReactPropTypes;
            return ReactPropTypes;
          };
        }).call(exports2, __webpack_require__(0));
      },
      /* 14 */
      /***/
      function(module2, exports2, __webpack_require__) {
        "use strict";
        var emptyFunction = __webpack_require__(1);
        var invariant = __webpack_require__(2);
        var ReactPropTypesSecret = __webpack_require__(5);
        module2.exports = function() {
          function shim(props, propName, componentName, location, propFullName, secret) {
            if (secret === ReactPropTypesSecret) {
              return;
            }
            invariant(
              false,
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
            );
          }
          ;
          shim.isRequired = shim;
          function getShim() {
            return shim;
          }
          ;
          var ReactPropTypes = {
            array: shim,
            bool: shim,
            func: shim,
            number: shim,
            object: shim,
            string: shim,
            symbol: shim,
            any: shim,
            arrayOf: getShim,
            element: shim,
            instanceOf: getShim,
            node: shim,
            objectOf: getShim,
            oneOf: getShim,
            oneOfType: getShim,
            shape: getShim,
            exact: getShim
          };
          ReactPropTypes.checkPropTypes = emptyFunction;
          ReactPropTypes.PropTypes = ReactPropTypes;
          return ReactPropTypes;
        };
      }
    ]);
  }
});

// node_modules/react-tradingview-widget/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-tradingview-widget/dist/index.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["react-tradingview-widget"] = factory();
      else
        root["react-tradingview-widget"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return webpackJsonpreact_tradingview_widget([1], {
        /***/
        8: (
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
            __webpack_require__.d(__webpack_exports__, "BarStyles", function() {
              return BarStyles;
            });
            __webpack_require__.d(__webpack_exports__, "IntervalTypes", function() {
              return IntervalTypes;
            });
            __webpack_require__.d(__webpack_exports__, "RangeTypes", function() {
              return RangeTypes;
            });
            __webpack_require__.d(__webpack_exports__, "Themes", function() {
              return Themes;
            });
            var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(9);
            var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
            var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(12);
            var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            function _objectWithoutProperties(obj, keys) {
              var target = {};
              for (var i in obj) {
                if (keys.indexOf(i) >= 0) continue;
                if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                target[i] = obj[i];
              }
              return target;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var BarStyles = {
              BARS: "0",
              CANDLES: "1",
              HOLLOW_CANDLES: "9",
              HEIKIN_ASHI: "8",
              LINE: "2",
              AREA: "3",
              RENKO: "4",
              LINE_BREAK: "7",
              KAGI: "5",
              POINT_AND_FIGURE: "6"
            };
            var IntervalTypes = {
              D: "D",
              W: "W"
            };
            var RangeTypes = {
              YTD: "ytd",
              ALL: "all"
            };
            var Themes = {
              LIGHT: "Light",
              DARK: "Dark"
            };
            var SCRIPT_ID = "tradingview-widget-script";
            var CONTAINER_ID = "tradingview-widget";
            var TradingViewWidget = function(_PureComponent) {
              _inherits(TradingViewWidget2, _PureComponent);
              function TradingViewWidget2() {
                var _ref;
                var _temp, _this, _ret;
                _classCallCheck(this, TradingViewWidget2);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TradingViewWidget2.__proto__ || Object.getPrototypeOf(TradingViewWidget2)).call.apply(_ref, [this].concat(args))), _this), _this.containerId = CONTAINER_ID + "-" + Math.random(), _this.componentDidMount = function() {
                  return _this.appendScript(_this.initWidget);
                }, _this.componentDidUpdate = function() {
                  _this.cleanWidget();
                  _this.initWidget();
                }, _this.canUseDOM = function() {
                  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
                }, _this.appendScript = function(onload) {
                  if (!_this.canUseDOM()) {
                    onload();
                    return;
                  }
                  if (_this.scriptExists()) {
                    if (typeof TradingView === "undefined") {
                      _this.updateOnloadListener(onload);
                      return;
                    }
                    onload();
                    return;
                  }
                  var script = document.createElement("script");
                  script.id = SCRIPT_ID;
                  script.type = "text/javascript";
                  script.async = true;
                  script.src = "https://s3.tradingview.com/tv.js";
                  script.onload = onload;
                  document.getElementsByTagName("head")[0].appendChild(script);
                }, _this.getScriptElement = function() {
                  return document.getElementById(SCRIPT_ID);
                }, _this.scriptExists = function() {
                  return _this.getScriptElement() !== null;
                }, _this.updateOnloadListener = function(onload) {
                  var script = _this.getScriptElement();
                  var oldOnload = script.onload;
                  return script.onload = function() {
                    oldOnload();
                    onload();
                  };
                }, _this.initWidget = function() {
                  if (typeof TradingView === "undefined" || !document.getElementById(_this.containerId)) return;
                  var _this$props = _this.props, widgetType = _this$props.widgetType, widgetConfig = _objectWithoutProperties(_this$props, ["widgetType"]);
                  var config = _extends({}, widgetConfig, { container_id: _this.containerId });
                  if (config.autosize) {
                    delete config.width;
                    delete config.height;
                  }
                  if (typeof config.interval === "number") {
                    config.interval = config.interval.toString();
                  }
                  if (config.popup_width && typeof config.popup_width === "number") {
                    config.popup_width = config.popup_width.toString();
                  }
                  if (config.popup_height && typeof config.popup_height === "number") {
                    config.popup_height = config.popup_height.toString();
                  }
                  new TradingView[widgetType](config);
                }, _this.cleanWidget = function() {
                  if (!_this.canUseDOM()) return;
                  document.getElementById(_this.containerId).innerHTML = "";
                }, _this.getStyle = function() {
                  if (!_this.props.autosize) return {};
                  return {
                    width: "100%",
                    height: "100%"
                  };
                }, _this.render = function() {
                  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("article", { id: _this.containerId, style: _this.getStyle() });
                }, _temp), _possibleConstructorReturn(_this, _ret);
              }
              return TradingViewWidget2;
            }(__WEBPACK_IMPORTED_MODULE_0_react__["PureComponent"]);
            TradingViewWidget.propTypes = {
              allow_symbol_change: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              autosize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              calendar: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              details: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              enable_publishing: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              height: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
              hideideas: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              hide_legend: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              hide_side_toolbar: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              hide_top_toolbar: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              hotlist: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              interval: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf([1, 3, 5, 15, 30, 60, 120, 180, "1", "3", "5", "15", "30", "60", "120", "180", IntervalTypes.D, IntervalTypes.W]),
              locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
              news: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),
              no_referral_id: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              popup_height: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),
              popup_width: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),
              range: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["1d", "5d", "1m", "3m", "6m", RangeTypes.YTD, "12m", "60m", RangeTypes.ALL]),
              referral_id: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
              save_image: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              show_popup_button: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
              studies: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),
              style: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf([BarStyles.BARS, BarStyles.CANDLES, BarStyles.HOLLOW_CANDLES, BarStyles.HEIKIN_ASHI, BarStyles.LINE, BarStyles.AREA, BarStyles.RENKO, BarStyles.LINE_BREAK, BarStyles.KAGI, BarStyles.POINT_AND_FIGURE]),
              symbol: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,
              theme: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf([Themes.LIGHT, Themes.DARK]),
              timezone: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
              toolbar_bg: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
              watchlist: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),
              widgetType: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
              width: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
              withdateranges: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool
            };
            TradingViewWidget.defaultProps = {
              allow_symbol_change: true,
              autosize: false,
              enable_publishing: false,
              height: 610,
              hideideas: true,
              hide_legend: false,
              hide_side_toolbar: true,
              hide_top_toolbar: false,
              interval: IntervalTypes.D,
              locale: "en",
              save_image: true,
              show_popup_button: false,
              style: BarStyles.CANDLES,
              theme: Themes.LIGHT,
              timezone: "Etc/UTC",
              toolbar_bg: "#F1F3F6",
              widgetType: "widget",
              width: 980,
              withdateranges: false
            };
            __webpack_exports__["default"] = TradingViewWidget;
          }
        )
      }, [8]);
    });
  }
});

// node_modules/react-tradingview-widget/index.js
var require_react_tradingview_widget = __commonJS({
  "node_modules/react-tradingview-widget/index.js"(exports, module) {
    if (typeof window === "undefined") {
      global.window = {};
    }
    require_manifest();
    if (typeof webpackJsonpreact_tradingview_widget === "undefined") {
      global.webpackJsonpreact_tradingview_widget = window["webpackJsonpreact_tradingview_widget"];
    }
    require_vendor();
    module.exports = require_dist();
  }
});
export default require_react_tradingview_widget();
/*! Bundled license information:

react-tradingview-widget/dist/vendor.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (** @license React v16.2.0
   * react.production.min.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v16.2.0
  * react.development.js
  *
  * Copyright (c) 2013-present, Facebook, Inc.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *)
*/
//# sourceMappingURL=react-tradingview-widget.js.map
